#!/bin/bash
# normal wget: wget "<url to download>" -o "<filename>"
# this script: cwget "<filename>" <-- gets url via xclip
#
# features:
# - take second entry from greenclip as possible filename
# - use yt-dlp or wget depending on clipboard content
# - try to continue downloading existing file after confirming continuation
# - can be called via system keybindings, then asks for filename via dmenu prompt
# - autocompletes with .mp4 if no suffix is given
# - also accepts curl calls

# if not executed from terminal ask for filename via dmenu
if [[ $TERM = linux ]]; then
	filename="$(dmenu -p 'Filename:' < /dev/null)"
	[[ -z $filename ]] &&
		[[ $(printf "no\\nyes" | dmenu -i -p 'Filename empty, continue?') != yes ]] &&
			exit 0

	# execute same script in new terminal session
	# and close terminal if successful
	eval "$TERMINAL -e ${BASH_SOURCE:-$0} --eval \"$filename\" && exit 0"

	exit $?
fi

source "$HOME/.config/shell/rc.d/00_colors"

set -e

case $1 in
	--eval) iseval=1 && shift;;
esac

[[ -n $iseval ]] && cd ${XDG_VIDEOS_DIR:-$HOME/Videos} || cd $(dirname -- "$1")

colorize () {
	printf "${BI}$1${NC}"
}

_yt-dlp() {
	read -p "\"Live stream\"? (y/N) " live
	[[ $live == [yY]* ]] && usets='--downloader ffmpeg --hls-use-mpegts'

	yt-dlp $usets "$@"
}

overwrite () {
	local f=$(colorize "$1")
	echo "[o]verwite or [c]ontinue $f? -- nothing to exit"
	read ANSWER
	case $ANSWER in
		[o])
			rm "$filename"
			printf "$f removed\n\n"
		;;
		[c])
			continue=1
			printf "continueing $f\n\n"
		;;
		*) exit 0 ;;
	esac
}

# get current clipboard content as downlaod source
get_url=$(xclip -selection clipboard -o -print0)

#echo "$get_url" | grep -oP 'http(?:s?):\/\/(?:www\.)?youtu(?:be\.com\/watch\?v=|\.be\/)([\w\-\_]*)'

# determine which tool to use
case $get_url in
 	*".m3u8"*) ytbts=1 ;;
	*"youtu"*) ytbts=1 && ytbraw=1 ;;
	"curl "*) crl=1 ;;
	"http"* ) wgt=1 ;;
	*       )
		echo "Clipboard content has no valid download pattern. Exiting."
		exit 0
	;;
esac

# try to guess filename from 2nd last entry of clipboard history using greenclip
cd - &> /dev/null
if [[ -z "$1" ]]
then
	[[ -z "$ytbraw" ]] && command -v greenclip &> /dev/null &&
    		filename="$(greenclip print | sed -n 2p)"
else
	filename="$1"
fi

# Check if file name is part of a series and increment episode number accordingly
files=( "$filename"* )
regx='(.*) S([0-9]{2})E([0-9]{2})'
if [[ $(printf "%s\n" "${files[@]}" | wc -l) -gt 0 ]]; then
	if [[ -f ${files[-1]} ]] && [[ "${files[-1]}" =~ $regx ]]; then
		title="${BASH_REMATCH[1]}"
		season="${BASH_REMATCH[2]}"
		episode=$((${BASH_REMATCH[3]}+1))
		episode=$(printf "%02d\n" $episode)
		filename="$title S${season}E${episode}"
	fi
fi

# if filename not empty & without file extension
[ -n "${filename}" ] && [ "$filename" == "${filename##*.}" ] &&
	filename="$filename.mp4"

# if filename not given just use yt-dlp and exit
[[ -z "$filename" ]] && _yt-dlp --embed-metadata -i "$get_url" && exit 0

# if file exists ask to continue or to overwrite file
[[ -f "$filename" ]] && overwrite "$filename"

# use youtube-dl
[[ -n $ytbts ]] && _yt-dlp ${usets} "$get_url" -o "$filename" && exit 0

[[ -n $ffmpeg ]] && \
	cat $get_url | \
		ffmpeg -protocol_whitelist file,http,https,tcp,tls \
		       -allowed_extensions ALL -i - \
		       -bsf:a aac_adtstoasc -c copy "$filename" && exit 0

# use curl (actually translating to wget syntax)
if [[ -n $crl ]] ; then
	get_url=$(echo ${get_url#curl } | sed -e 's/-H/--header/g')
	wgt=1
fi

# use wget
if [[ -n $wgt ]] ; then
	[[ -n $continue ]] && wget_parms="-c"
	while true ; do
		[[ -f "$filename" ]] && wget_parms="-c"
		eval "wget -T 5 $wget_parms $get_url -O '$filename' && break;"
	done
fi
